# Testable Report
## Анализ тестопригодности

Итак, благодаря правильно выстроенной архитектуре, классы с основной бизнес-логикой легко смогут быть протестированными за счет интерфейсов и зависимостей, которые передаются через конструктор. Иными словами, у них нет неявных входных параметров.

---

### Классы, пригодные для тестирования

#### **AuthServiceImpl**
- **Описание:** Сервис аутентификации.
- **Зависимости:** `UserRepository` внедряется через конструктор.
- **Особенности:** Логика (`authenticate`) — чистая функция, использующая простую утилиту для хэширования.
- **Сценарии тестирования:**
    - Успешная аутентификация
    - Неверный пароль
    - Пользователь не найден

---

#### **AccessControllerImpl**
- **Описание:** Контроллер доступа.
- **Зависимости:** `ResourceRepository` внедряется.
- **Особенности:** Логика проверки разрешений основана на иерархии путей, что делает её идеально подходящей для тестирования границ и правил.
- **Сценарии тестирования:**
    - Разрешение найдено
    - Разрешение найдено по родительскому пути
    - В доступе отказано
    - Ресурс не существует

---

#### **VolumeValidatorImpl**
- **Описание:** Валидатор объема.
- **Зависимости:** Не имеет внешних зависимостей.
- **Особенности:** Метод `validate` является чистой функцией — он всегда даёт одинаковый результат для одинаковых входных данных.
- **Сценарии тестирования:**
    - Успешная валидация (`0 < volume < max`)
    - `volume` отрицательный
    - `volume` превышает `maxVolume`

---

#### **HashPassword**
- **Описание:** Утилита хэширования.
- **Особенности:** Статически доступная утилита (`Singleton/Object`) с чистыми функциями (`hash`, `toBase64`, `fromBase64`). Не имеет состояния.
- **Сценарии тестирования:**
    - Корректность хэширования (два одинаковых пароля с одинаковой солью дают одинаковый хэш)
    - Корректность работы Base64-конвертации
    - Генерация соли

---

#### **RequestProcessor**
- **Описание:** Оркестратор.
- **Зависимости:** `AuthService`, `AccessController`, `VolumeValidator`, `ResourceRepository` внедряются через конструктор.
- **Особенности:** Поток логики — последовательность вызовов сервисов.
- **Сценарии тестирования:**
    - Полный успешный сценарий
    - Отказ на каждом шаге:
        - Неверный пароль
        - Ресурс не найден
        - Доступ запрещен
        - Превышение объема
- **Методика:** Тестируется с помощью моков для всех зависимостей.

---

#### **InMemoryUserRepositoryImpl**
- **Описание:** Репозиторий данных.
- **Особенности:** Реализует интерфейс `UserRepository`. Содержит неизменяемое внутреннее состояние (`private val users`), что исключает побочные эффекты между тестами.
- **Сценарии тестирования:**
    - Поиск существующего пользователя
    - Поиск несуществующего пользователя

---

#### **InMemoryResourceRepositoryImpl**
- **Описание:** Репозиторий данных.
- **Особенности:** Аналогично `InMemoryUserRepositoryImpl`. Легко тестируется, поскольку имеет неизменяемое состояние.
- **Сценарии тестирования:**
    - Поиск существующего ресурса
    - Поиск несуществующего ресурса

---

### Классы, слабо поддающиеся тестированию

В проекте, конечно же, есть классы, которые не поддаются тестированию, так как находятся "на грани", то есть взаимодействуют с внешними системными вызовами.

#### **ExitCodeProcessor**
```kotlin
object ExitCodeProcessor {
    fun finish(code: ExitCode) {
        exitProcess(code.code)
    }
}
```

Тут, как можно наблюдать, вызывается exitProcess, то есть заканчивает работу всей программы. Смысла в тестировании здесь нет. 
Также как и объект "AppComponents", который по факту является DI слоем.

AppArgsParser также тяжело протестировать. Он зависит от внешней библиотеки (ArgParser) и оперирует массивом строк I/O. 
Содержит нетривиальный блок try/catch. Сложно мокировать внешнюю библиотеку.







