# Анализ проекта. План рефакторинга
## Разбор ошибок: 
1. Зачем в проекте котлин компилятор?
В проекте он использовался для запуска проекта на версии kotlin чуть ниже, чем предлагалось. 
Это было нужно для проверки гипотезы о несовместимости нужных библиотек с версией kotlin.
Гипотеза опроверглась, теперь его можно смело удалить.

2. Зачем в проекте котлин компилятор?
Скомпилированные .class-файлы оказались в репозитории по ошибке (их создаёт компилятор).
Они не нужны в исходниках и будут добавлены в .gitignore, чтобы не засорять проект.

3. Зачем в проекте билд-архив?
Файл app.jar (или аналогичный билд-архив) добавлен для локального тестирования программы без IDE.
В рабочей версии проекта этот файл должен создаваться автоматически при сборке и не храниться в репозитории.
Также будет добавлен в .gitignore.

4.  Resource вроде и структура данных, а вроде и ищет другие ресурсы
Да, сейчас Resource совмещает модель данных и логику поиска, что нарушает принцип единственной ответственности.
Планирую разделить:
- Resource — чистая структура (имя, объём, права, ссылка на родителя);
- ResourceTree (или ResourceRepository) — отдельный класс, отвечающий за поиск ресурсов и навигацию по иерархии.

5.  Лучше вместо указания дочерних ресурсов укажите родительский, тк он один
Окей, хранить ссылки на всех дочерних ресурсов усложняет модель и дублирует данные.
Будет изменено: у ресурса будет один parent: Resource?, а построение дерева будет выполняться отдельной функцией.

6.  User вроде структура для данных пользователя, а вроде и пароль захэширует, и доступ проверит, 
и в горящую избу войдет пароли проверит.
Да, сейчас User совмещает хранение данных и бизнес-логику (валидацию, проверку прав).
Лучше исправить примерно вот так:
- User останется как data class (только логин, хэш, права);
- AuthService или UserManager будет отвечать за проверку паролей и прав доступа.

7. Коды завершения указывать хардкодом - плохой тон.
Хорошо, исправим - создадим enum class ExitCode или object ExitCodes с константами.

8. Мейн слишком занятой товарищ получается: аргументы парсит, валидирует эти аргументы, объем проверяет и тд (SRP).
Окей, Будет вынесено примерно так: 
- Парсинг аргументов → отдельный класс AppArgsParser;
- Проверка логики → AccessController или RequestProcessor;
- main() останется только точкой входа и делегированием задач.

9. Не используются эксепшоны совсем.
Да, обработка ошибок реализована через exitProcess, что делает код менее гибким. Исправим.\

10. Права доступа жестко заданы строками (enum)
Да, строки "read", "write", "execute" лучше заменить на enum class Action { READ, WRITE, EXECUTE }.

## SOLID
Обзор текущей структуры:
- [Main.kt](src/Main.kt) — точка входа; парсинг аргументов; последовательная валидация; вызовы логики.
- [User.kt](src/user/User.kt) — класс User (login, passwordHash, salt, методы хэширования и проверки пароля, проверка прав).
- [CreateUsers.kt](src/user/CreateUsers.kt) — здесь создаем список заранее заданных пользователей users.
- [Resourse.kt](src/resources/Resourse.kt) — data class Resource + findResource() 
- [CreateResources.kt](src/resources/CreateResources.kt) — val root = Resource() — жестко зашитое дерево ресурсов.
- `src/...` — скрипты `build.sh`, `run.sh`, `test.sh` (инфраструктура).

Нарушения SOLID:

### 1) **Single Responsibility Principle — нарушен**
Мэйн выполняет множество обязанностей: парсит аргументы, валидирует формат, 
аутентифицирует пользователя, проверяет права, проверяет объём и возвращает код выхода.
Что нужно исправить:
- Вынести обязанности в отдельные классы/сервисы:
    - AppArgsParser — парсинг CLI → возвращает DTO AccessRequest.
    - AuthService — верификация логина/пароля.
    - ResourceRepository — поиск ресурсов, получение maxVolume.
    - AccessController — проверка прав (наследование).
    - RequestProcessor — оркестратор, который использует предыдущие сервисы и возвращает `ExitCode`.
- мэйн должен только вызывать AppArgsParser.parse(args) → RequestProcessor.process(request) → exitProcess(code).

### 2) **Open/Closed Principle — нарушен(частично)**
Сейчас в [CreateUsers.kt](src/user/CreateUsers.kt) жестко зашитый список пользователей и строковые права.
Добавление логики проверки новых правил или источников данных потребует изменения существующего кода. 
Кроме того, действия представлены строками — расширение типа действия потребует изменения частей, где сравниваются строки.
Предложение:
- Вынести данные пользователей в UserRepository (интерфейс) и оставить реализацию InMemoryUserRepository.
- Заменить строковые права на enum class Action { READ, WRITE, EXECUTE }.
- Использовать интерфейсы так, чтобы можно было добавить DatabaseUserRepository без изменения остального кода.

### 3) **Liskov Substitution Principle — нарушен(частично)**
[User.kt](src/user/User.kt) реализует и хранение данных и операции проверки.
Неявный — если мы заменим User на другую реализацию, поведение checkPassword или checkPermission может поменяться. 
Пока нет иерархии наследования, LSP не критичен, но текущая модель затрудняет безопасную подмену.
Предложение:
- Разделить ответственность: User → простой POJO/data class, AuthService и AccessController — отдельные реализации. 
- Тогда разные реализации AuthService можно будет подменять без ломки.

### 4) **Interface Segregation Principle — нарушен**
[User.kt](src/user/User.kt) имеет несколько ролей
Сейчас у User один класс, выполняющий данные и поведение аутентификации/авторизации — интерфейсы не выделены, 
потребители вынуждены знать о лишнем поведении.
Предложение:
- Определить узкие интерфейсы IUserData (только данные), IAuthProvider (авторизация) — и использовать их по месту.

### 5) **Dependency Inversion Principle — нарушен**
Жестко создаются users, root и вызывает конкретные реализации.
Модули верхнего уровня зависят от конкретных реализаций. Это мешает тестированию и расширяемости.
Предложение:
- Ввести инъекцию зависимостей через конструктор/фабрики:
RequestProcessor(authService: AuthService, repo: ResourceRepository, accessController: AccessController)
- Для простоты использовать фабричный объект AppComponents.createDefault() в main, 
но код процессора не должен создавать зависимости сам.
